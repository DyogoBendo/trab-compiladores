// CLexer.jj

options {
  STATIC = false;
}

PARSER_BEGIN(CLexer)

import lexer.ParseException;import parser.ParserNode;
import java.io.StringReader;
import java.util.Map;
import exception.LexicalException;
import exception.SemanticException;
import symboltable.SemanticRecord;
import symboltable.Symbol;
import symboltable.SymbolTable;


public class CLexer {
    private Map<String, Token> symbolTable;
    private Map<String, Token> reservedWordTable;
    private SymbolTable identifierTable;

    public void setTables(Map<String, Token> symbolTable, Map<String, Token> reservedWordTable, SymbolTable identifierTable) {
        this.symbolTable = symbolTable;
        this.reservedWordTable = reservedWordTable;
        this.identifierTable = identifierTable;
    }

    private void recordToken() {
        Token t = getToken(0);
        reservedWordTable.putIfAbsent(t.image, t);
    }

    final public void throwSyntacticError(String message) throws ParseException {
        Token currentToken = getToken(0);
        throw new ParseException(message + " (linha: " + currentToken.beginLine + ", coluna: " + currentToken.beginColumn + ").");
    }

}

PARSER_END(CLexer)

// Ignorar espaços, quebra de linha e comentários
SKIP : { " " }
SKIP : { "\t" }
SKIP : { "\n" }
SKIP : { "\r" }
SKIP : { <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> } // Comentário em uma linha única
SKIP : { <"/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/"> } // Comentários de múltiplas linhas

// Tokens auxiliares
TOKEN: {
    < #LETTER: ["a"-"z", "A"-"Z"] >
    | < #DIGIT: ["0"-"9"] >
}

// Palavras reservadas (Keywords)
TOKEN : { < KW_BREAK: "break" > }
TOKEN : { < KW_CASE: "case" > }
TOKEN : { < KW_CHAR: "char" > }
TOKEN : { < KW_CONTINUE: "continue" > }
TOKEN : { < KW_DEFAULT: "default" > }
TOKEN : { < KW_DOUBLE: "double" > }
TOKEN : { < KW_ELSE: "else" > }
TOKEN : { < KW_FLOAT: "float" > }
TOKEN : { < KW_FOR: "for" > }
TOKEN : { < KW_IF: "if" > }
TOKEN : { < KW_INT: "int" > }
TOKEN : { < KW_LONG: "long" > }
TOKEN : { < KW_PAPIBAGRIFAR: "papibagrifar" > }
TOKEN : { < KW_PAPIBAQUIGRAFAR: "papibaquigrafar" > }
TOKEN : { < KW_RETURN: "return" > }
TOKEN : { < KW_SIGNED: "signed" > }
TOKEN : { < KW_SIZEOF: "sizeof" > }
TOKEN : { < KW_STRUCT: "struct" > }
TOKEN : { < KW_TYPEDEF: "typedef" > }
TOKEN : { < KW_UNSIGNED: "unsigned" > }
TOKEN : { < KW_VOID: "void" > }
TOKEN : { < KW_WHILE: "while" > }

// Operadores
TOKEN : {
  < PLUS: "+" >
  | < MINUS: "-" >
  | < STAR: "*" >
  | < DIVIDE: "/" >
  | < MODULO: "%" >
  | < EXPO: "**" >
  | < ASSIGN: "=" >
  | < EQ: "==" >
  | < NE: "!=" >
  | < LT: "<" >
  | < GT: ">" >
  | < LE: "<=" >
  | < GE: ">=" >
  | < AND: "&&" >
  | < OR: "||" >
  | < NOT: "!" >
  | < INC: "++" >
  | < DEC: "--" >
  | < PLUS_ASSIGN: "+=" >
  | < MINUS_ASSIGN: "-=" >
  | < MULTIPLY_ASSIGN: "*=" >
  | < DIVIDE_ASSIGN: "/=" >
  | < MODULO_ASSIGN: "%=" >
  | < QUESTION: "?" >
  | < COLON: ":" >
  | < BIT_AND: "&" >
  | < BIT_AND_ASSIGN: "&=" >
  | < BIT_OR: "|" >
  | < BIT_OR_ASSIGN: "|=" >
  | < BIT_XOR: "^" >
  | < BIT_XOR_ASSIGN: "^=" >
  | < BIT_NOT: "~" >
  | < BIT_NOT_ASSIGN: "~=" >
  | < LSHIFT: "<<" >
  | < LSHIFT_ASSIGN: "<<=" >
  | < RSHIFT: ">>" >
  | < RSHIFT_ASSIGN: ">>=" >

  |< INVALID_OPERATOR: "===" | "$" | "..." >
}

// delimitadores e separadores
TOKEN : {
    < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < SEMICOLON: ";" >
  | < COMMA: "," >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < DOT: "." >
  | < ARROW: "->" >
}


// Literais e erros literais
TOKEN : {
  // Erros
    < UNTERMINATED_CHAR: "'" (~["'","\n","\r"])? ("\n"|"\r"|"\r\n") >
  | < MULTIPLE_DECIMAL_POINTS: (<DIGIT>)+ "." (<DIGIT>)* "." (<DIGIT>)* >

  | < DECIMAL_LITERAL:
        (<DIGIT>)+ "." (<DIGIT>)* (("e"|"E") (<PLUS>|<MINUS>)? (<DIGIT>)+)?
      | "." (<DIGIT>)+ (("e"|"E") (<PLUS>|<MINUS>)? (<DIGIT>)+)?
      | (<DIGIT>)+ ("e"|"E") (<PLUS>|<MINUS>)? (<DIGIT>)+
  >
  | < INTEGER_LITERAL: (<DIGIT>)+ >
  | < CHAR_LITERAL: "'" ("\\")? (~["'","\n","\r"]) "'" >
  | < STRING_LITERAL: "\"" (~["\"","\n","\r"])* "\"" >
}

// Identificadores, para funções, variáveis etc
TOKEN : {
  < IDENTIFIER: (<LETTER> | "_") (<LETTER>|<DIGIT>|"_")* >
  | < INVALID_IDENTIFIER: (<DIGIT>)+ (<LETTER>|<DIGIT>|"_")* > // precisa vir depois do número, senão número seria considerado um identificador
}

// ----------- Regras sintáticas ---------

// Tipos
String typeSpecifier(ParserNode parent):
{
    ParserNode node = new ParserNode("typeSpecifier");
    parent.addChild(node);
    Token t;
    String tipoEncontrado = "";
}
{
    (
      t=<KW_CHAR>   { recordToken(); node.addChild(new ParserNode("KW_CHAR"));   tipoEncontrado = t.image; }
    | t=<KW_FLOAT>  { recordToken(); node.addChild(new ParserNode("KW_FLOAT"));  tipoEncontrado = t.image; }
    | t=<KW_INT>    { recordToken(); node.addChild(new ParserNode("KW_INT"));    tipoEncontrado = t.image; }
    | t=<KW_LONG>   { recordToken(); node.addChild(new ParserNode("KW_LONG"));   tipoEncontrado = t.image; }
    | t=<KW_DOUBLE> { recordToken(); node.addChild(new ParserNode("KW_DOUBLE")); tipoEncontrado = t.image; }
    | t=<KW_VOID>   { recordToken(); node.addChild(new ParserNode("KW_VOID"));   tipoEncontrado = t.image; }

    | t=<IDENTIFIER>
      {
          identifierTable.checkStruct(t);
          node.addChild(new ParserNode("IDENTIFIER"));
          tipoEncontrado = t.image;
      }
    )

    (
        <STAR>
        {
            recordToken();
            node.addChild(new ParserNode("STAR"));
            tipoEncontrado += "*";
        }
    )?

    { return tipoEncontrado; }
}

// Argumentos de uma função
void functionArguments(ParserNode parent):
{
    ParserNode node = new ParserNode("functionArguments");
    parent.addChild(node);
}
{
    (expression(node) (<COMMA> { recordToken(); node.addChild(new ParserNode("COMMA")); } expression(node))*)?
}

// Chamada de uma função
void functionCallStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("functionCallStatement");
    parent.addChild(node);
    Token t;
}
{
    t=<IDENTIFIER> { identifierTable.checkFunction(t); node.addChild(new ParserNode("IDENTIFIER")); }
    <LPAREN> { recordToken(); node.addChild(new ParserNode("LPAREN")); }
    functionArguments(node)
    <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN")); }
    endOfStatement(node)
}

// parâmetro de uma função
void parameter(ParserNode parent):
{
    ParserNode node = new ParserNode("parameter");
    parent.addChild(node);
    Token t;
    String declaredType;
}
{
    declaredType = typeSpecifier(node)
    t=<IDENTIFIER>
    {
        symbolTable.putIfAbsent(t.image, t);
        identifierTable.add(t, declaredType);
        node.addChild(new ParserNode("IDENTIFIER"));
        Symbol s = identifierTable.getSymbol(t);
        if (s != null) {
            s.setInitialized(true);
        }
    }
}

// parâmetros de uma função
void functionParams(ParserNode parent):
{
    ParserNode node = new ParserNode("functionParams");
    parent.addChild(node);
}
{
    (parameter(node) ( <COMMA> {recordToken(); node.addChild(new ParserNode("COMMA")); } parameter(node) )* )?
}

// declaração de uma função
void functionDeclaration(ParserNode parent):
{
    ParserNode node = new ParserNode("functionDeclaration");
    parent.addChild(node);
    Token t;
    String typeDeclared;
}
{
     typeDeclared = typeSpecifier(node)
     t=<IDENTIFIER> { symbolTable.putIfAbsent(t.image, t); identifierTable.add(t, typeDeclared); node.addChild(new ParserNode("IDENTIFIER")); }
     <LPAREN> { recordToken(); node.addChild(new ParserNode("LPAREN")); identifierTable.enterScope();}
     functionParams(node)
     <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN")); }
     block(node)
     {identifierTable.leaveScope();}

}

// retorno de uma função
void functionReturnStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("functionReturnStatement");
    parent.addChild(node);
}
{
    <KW_RETURN> { recordToken(); node.addChild(new ParserNode("KW_RETURN")); }
    ( LOOKAHEAD(2) expression(node))?
    endOfStatement(node)
}

// loop for
void forStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("forStatement");
    parent.addChild(node);
}
{
     <KW_FOR>  { recordToken(); node.addChild(new ParserNode("KW_FOR")); }
     <LPAREN> { recordToken(); node.addChild(new ParserNode("LPAREN")); identifierTable.enterScope();}
     (
        LOOKAHEAD( variableDeclaration() )
        variableDeclaration(node)
        |
        assignmentStatement(node)
        |
        <SEMICOLON> { recordToken(); node.addChild(new ParserNode("SEMICOLON")); }
     )
     expression(node)
     <SEMICOLON> { recordToken(); node.addChild(new ParserNode("SEMICOLON")); }
     (expression(node))?
     <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN"));}
     statement(node)
     {identifierTable.leaveScope();}
}

// loop while
void whileStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("whileStatement");
    parent.addChild(node);
}
{
     <KW_WHILE> { recordToken(); node.addChild(new ParserNode("KW_WHILE")); }
     <LPAREN> { recordToken(); node.addChild(new ParserNode("LPAREN")); }
     expression(node)
     <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN")); }
     statement(node)
}

// bloco
void block(ParserNode parent):
{
    ParserNode node = new ParserNode("block");
    parent.addChild(node);
}
{
    <LBRACE> { recordToken(); node.addChild(new ParserNode("LBRACE")); identifierTable.enterScope(); }
    ( LOOKAHEAD(2) statement(node) )*
    (
        <RBRACE> { recordToken(); node.addChild(new ParserNode("RBRACE")); identifierTable.leaveScope();}
        | <EOF> { throwSyntacticError("Erro de sintaxe: o bloco não foi fechado antes do final do arquivo."); }
    )
}

void conditionalExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("conditionalExpression");
    parent.addChild(node);
}
{
     <LPAREN> {recordToken(); node.addChild(new ParserNode("LPAREN")); } expression(node) <RPAREN> {recordToken(); node.addChild(new ParserNode("RPAREN")); }
}


void breakStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("breakStatement");
    parent.addChild(node);
}
{
    <KW_BREAK> { recordToken(); node.addChild(new ParserNode("KW_BREAK")); }
    endOfStatement(node)
}

void continueStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("continueStatement");
    parent.addChild(node);
}
{
    "continue" { recordToken(); node.addChild(new ParserNode("KW_CONTINUE")); }
    endOfStatement(node)
}

void papibagrifarCaseOnlyGroup(ParserNode parent):
{
    ParserNode node = new ParserNode("papibagrifarCaseOnlyGroup");
    parent.addChild(node);
}
{
    (
        LOOKAHEAD(2)
        <KW_CASE> { recordToken(); node.addChild(new ParserNode("KW_CASE")); }
        expression(node)
        <COLON> { recordToken(); node.addChild(new ParserNode("COLON")); }
    )+
    ( statement(node) )*
}

void papibagrifarDefaultGroup(ParserNode parent):
{
    ParserNode node = new ParserNode("papibagrifarDefaultGroup");
    parent.addChild(node);
}
{
    <KW_DEFAULT> { recordToken(); node.addChild(new ParserNode("KW_DEFAULT")); }
    <COLON> { recordToken(); node.addChild(new ParserNode("COLON")); }
    ( statement(node) )*
}


void papibagrifarStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("papibagrifarStatement");
    parent.addChild(node);
}
{
    <KW_PAPIBAGRIFAR> { recordToken(); node.addChild(new ParserNode("KW_PAPIBAGRIFAR")); }
    <LPAREN> { recordToken(); node.addChild(new ParserNode("LPAREN")); }
    expression(node)
    <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN")); }

    <LBRACE> { recordToken(); node.addChild(new ParserNode("LBRACE")); }
    (
        LOOKAHEAD( (papibagrifarCaseOnlyGroup(node))* papibagrifarDefaultGroup(node) )
        ( papibagrifarCaseOnlyGroup(node) )*
        papibagrifarDefaultGroup(node)
    |
        ( papibagrifarCaseOnlyGroup(node) )*
        {
          throw new ParseException("Erro de sintaxe: a instrução 'papibagrifar' deve conter exatamente um 'default'.");
        }
    )

    <RBRACE> { recordToken(); node.addChild(new ParserNode("RBRACE")); }
}

void conditionalStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("conditionalStatement");
    parent.addChild(node);
}
{
     <KW_IF> { recordToken(); node.addChild(new ParserNode("KW_IF")); }
     conditionalExpression(node)
     statement(node)
     ( LOOKAHEAD(2) <KW_ELSE> { recordToken(); node.addChild(new ParserNode("KW_ELSE")); } statement(node))?
}

SemanticRecord primaryExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("primaryExpression");
    parent.addChild(node);
    Token t;
    SemanticRecord result = null;
}
{
    (
    t=<INTEGER_LITERAL> {
        symbolTable.putIfAbsent(t.image, t);
        node.addChild(new ParserNode("INTEGER"));
        result = new SemanticRecord("int", Integer.parseInt(t.image));
    }
    | t=<DECIMAL_LITERAL> {
        symbolTable.putIfAbsent(t.image, t);
        node.addChild(new ParserNode("DECIMAL"));
        result = new SemanticRecord("float", Float.parseFloat(t.image));
    }
    | t=<CHAR_LITERAL> {
        symbolTable.putIfAbsent(t.image, t);
        node.addChild(new ParserNode("CHAR"));
        char c = t.image.charAt(1);
        result = new SemanticRecord("char", c);
    }
    | t=<STRING_LITERAL> {
        symbolTable.putIfAbsent(t.image, t);
        node.addChild(new ParserNode("STRING"));
        String val = t.image.substring(1, t.image.length() - 1);
        result = new SemanticRecord("string", val);
    }
    | t=<IDENTIFIER> {
        identifierTable.checkVariable(t);
        node.addChild(new ParserNode("IDENTIFIER"));
        Symbol s = identifierTable.getSymbol(t);
        if (!s.isInitialized()) throw new SemanticException(t, "Erro: Variável '" + t.image + "' não foi inicializada.");
        result = new SemanticRecord(s.getType(), s.getValue(), s);
    }
    | <LPAREN> {recordToken(); node.addChild(new ParserNode("LPAREN")); }
    result = expression(node)
    <RPAREN> { recordToken(); node.addChild(new ParserNode("RPAREN")); }
    )

    { return result; }
}

SemanticRecord postfixExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("postfixExpression");
    parent.addChild(node);
    SemanticRecord result = null;
    Token op = null;
}
{
    result = primaryExpression(node)
    (
    LOOKAHEAD(2)
        (
            op = <INC> { recordToken(); node.addChild(new ParserNode("INC")); }
        |   op = <DEC> { recordToken(); node.addChild(new ParserNode("DEC")); }
        )
    )?

    {
        if (op == null || result.value == null) return result;
        if (result.sourceSymbol == null) throw new SemanticException(op, "É necessário um l-value (variável) para incrementar/decrementar.");
        if (!result.type.equals("int")) throw new SemanticException(op, "++ e -- são permitidos apenas para inteiros.");

        int oldValue = (Integer) result.value;
        int newVal;

        if (op.kind == INC) newVal = oldValue + 1;
        else newVal = oldValue - 1;

        result.sourceSymbol.setValue(newVal);
        return new SemanticRecord(result.type, oldValue, null);
    }
}

SemanticRecord unaryExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("unaryExpression");
    parent.addChild(node);
    SemanticRecord result = null;
    Token op = null;
}
{
    (
        op = <INC>   {recordToken(); node.addChild(new ParserNode("INC")); }
      | op = <DEC>   { recordToken(); node.addChild(new ParserNode("DEC")); }
      | op = <PLUS>  { recordToken(); node.addChild(new ParserNode("PLUS")); }
      | op = <MINUS> { recordToken(); node.addChild(new ParserNode("MINUS")); }
      | op = <NOT>   { recordToken(); node.addChild(new ParserNode("NOT")); }
      | op = <BIT_NOT> { recordToken(); node.addChild(new ParserNode("BIT_NOT")); }
    )?
    result = postfixExpression(node)

    {
        if (op == null) return result;

        Object val = result.getValue();
        String type = result.getType();
        Object newVal = null;

        if (val == null) return result;

        if (op.kind == MINUS) {
            if (type.equals("int")) {
                newVal = -((Integer) val);
            } else if (type.equals("float")) {
                newVal = -((Float) val);
            } else {
                throw new SemanticException(op, "Operador '-' inválido para o tipo " + type);
            }
        }
        else if (op.kind == NOT) {
            if (type.equals("int")) {
                int v = (Integer) val;
                newVal = (v == 0) ? 1 : 0;
            } else {
                throw new SemanticException(op, "Operador '!' requer um valor inteiro/lógico.");
            }
        }
        else if (op.kind == BIT_NOT) {
            if (type.equals("int")) {
                newVal = ~((Integer) val);
            } else {
                throw new SemanticException(op, "Operador '~' só é permitido para inteiros.");
            }
        }
        else if (op.kind == INC || op.kind == DEC) {
            if (result.sourceSymbol == null) {
                throw new SemanticException(op, "É necessário um l-value (variável) para incrementar/decrementar.");
            }

            if (type.equals("int")) {
                int v = (Integer) val;
                if (op.kind == INC) newVal = v + 1;
                else newVal = v - 1;
                result.sourceSymbol.setValue(newVal);
            } else {
                throw new SemanticException(op, "++ e -- são permitidos apenas para inteiros.");
            }
        }

        if (newVal != null) {
            result = new SemanticRecord(type, newVal, null);
        }
        
        return result;
    }
}

SemanticRecord multiplicativeExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("multiplicativeExpression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = unaryExpression(node)
    (
        (
            op = <STAR>   { recordToken(); node.addChild(new ParserNode("MULTIPLY")); }
          | op = <DIVIDE> { recordToken(); node.addChild(new ParserNode("DIVIDE")); }
          | op = <MODULO> { recordToken(); node.addChild(new ParserNode("MODULO")); }
          | op = <EXPO>   { recordToken(); node.addChild(new ParserNode("EXPO")); }
        )
        right = unaryExpression(node)
        {
            if (left.type == null || right.type == null){}
            else { 
                if (!left.type.equals(right.type)) {
                    throw new SemanticException(op, "Operação inválida entre tipos diferentes: " + left.type + " e " + right.type);
                }

                if (!left.type.equals("int") && !left.type.equals("float")) {
                     throw new SemanticException(op, "Operações aritméticas (*, /, %, ^) permitidas apenas para números.");
                }

                if (op.kind == MODULO && !left.type.equals("int")) {
                    throw new SemanticException(op, "O operador '%' (resto) é permitido apenas para números inteiros.");
                }

                Object newVal = null;

                if (left.value != null && right.value != null) {
                    if (left.type.equals("int")) {
                        int v1 = (Integer) left.value;
                        int v2 = (Integer) right.value;

                        if (op.kind == STAR) {
                            newVal = v1 * v2;
                        } else if (op.kind == DIVIDE) {
                            if (v2 == 0) throw new SemanticException(op, "Erro: Divisão por zero.");
                            newVal = v1 / v2;
                        } else if (op.kind == MODULO) {
                            if (v2 == 0) throw new SemanticException(op, "Erro: Módulo por zero.");
                            newVal = v1 % v2;
                        } else if (op.kind == EXPO) {
                            newVal = (int) Math.pow((double)v1, (double)v2);
                        }
                    }
                    else if (left.type.equals("float")) {
                        float v1 = (Float) left.value;
                        float v2 = (Float) right.value;

                        if (op.kind == STAR) {
                            newVal = v1 * v2;
                        } else if (op.kind == DIVIDE) {
                            if (v2 == 0.0f) throw new SemanticException(op, "Erro: Divisão por zero.");
                            newVal = v1 / v2;
                        } else if (op.kind == EXPO) {
                            newVal = (float) Math.pow((double)v1, (double)v2);
                        }
                    }
                }
                
                left = new SemanticRecord(left.type, newVal, null);
            }
        }
    )*

    { return left; }
}

SemanticRecord additiveExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("additiveExpression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = multiplicativeExpression(node)
    (
        LOOKAHEAD(2)
        ( op = <PLUS> {recordToken(); node.addChild(new ParserNode("PLUS")); } | op = <MINUS> {recordToken(); node.addChild(new ParserNode("MINUS")); } )
        right = multiplicativeExpression(node)
        {
            if (left.type == null || right.type == null) {}
            else { 
                if (!left.type.equals(right.type)) {
                    throw new SemanticException(op, "Operação inválida entre tipos diferentes: " + left.type + " e " + right.type);
                }

                if (!left.type.equals("int") && !left.type.equals("float")) {
                     throw new SemanticException(op, "Operações aritméticas (+, -) permitidas apenas para números.");
                }

                Object newVal = null;

                if (left.getValue() != null && right.getValue() != null) {
                    if (left.type.equals("int")) {
                        int v1 = (Integer) left.getValue();
                        int v2 = (Integer) right.getValue();

                        if (op.kind == PLUS) {
                            newVal = v1 + v2;
                        } else if (op.kind == MINUS) {
                            newVal = v1 - v2;
                        }
                    }
                    else if (left.type.equals("float")) {
                        float v1 = (Float) left.getValue();
                        float v2 = (Float) right.getValue();

                        if (op.kind == PLUS) {
                            newVal = v1 + v2;
                        } else if (op.kind == MINUS) {
                            newVal = v1 - v2;
                        }
                    }
                }
                
                left = new SemanticRecord(left.type, newVal, null);
            }
        }
    )*

    { return left; }
}

SemanticRecord bitExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("bitExpression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = additiveExpression(node)
    (
        (
              op = <BIT_AND> {recordToken(); node.addChild(new ParserNode("BIT_AND")); }
            | op = <BIT_OR>  {recordToken(); node.addChild(new ParserNode("BIT_OR"));  }
            | op = <BIT_XOR> {recordToken(); node.addChild(new ParserNode("BIT_XOR")); }
            | op = <LSHIFT>  {recordToken(); node.addChild(new ParserNode("LSHIFT"));  }
            | op = <RSHIFT>  {recordToken(); node.addChild(new ParserNode("RSHIFT"));  }
        )
        right = additiveExpression(node)
        {
            if (left.type != null && right.type != null) {
                if (!left.type.equals("int") || !right.type.equals("int")) {
                    throw new SemanticException(op, "Operações bit-a-bit (&, |, ^, <<, >>) exigem operandos inteiros.");
                }

                Object newVal = null;
                if (left.getValue() != null && right.getValue() != null) {
                    int v1 = (Integer) left.getValue();
                    int v2 = (Integer) right.getValue();

                    if (op.kind == BIT_AND)      newVal = v1 & v2;
                    else if (op.kind == BIT_OR)  newVal = v1 | v2;
                    else if (op.kind == BIT_XOR) newVal = v1 ^ v2;
                    else if (op.kind == LSHIFT)  newVal = v1 << v2;
                    else if (op.kind == RSHIFT)  newVal = v1 >> v2;
                }
                
                left = new SemanticRecord("int", newVal, null);
            }
        }
    )*
    
    { return left; }
}


SemanticRecord relationalExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("relationalExpression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = bitExpression(node)
    (
        (
              op = <LT>  {recordToken(); node.addChild(new ParserNode("LT")); }
            | op = <GT>  {recordToken(); node.addChild(new ParserNode("GT")); }
            | op = <LE>  {recordToken(); node.addChild(new ParserNode("LE")); }
            | op = <GE>  {recordToken(); node.addChild(new ParserNode("GE")); }
            | op = <EQ>  {recordToken(); node.addChild(new ParserNode("EQ")); }
            | op = <NE> {recordToken(); node.addChild(new ParserNode("NE"));  }
        )
        right = bitExpression(node)
        {
            if (left.type != null && right.type != null) {
                if (!left.type.equals(right.type)) {
                     throw new SemanticException(op, "Comparação inválida entre tipos diferentes: " + left.type + " e " + right.type);
                }

                Object newVal = null;
                if (left.getValue() != null && right.getValue() != null) {
                    boolean res = false;
                    
                    if (left.type.equals("int")) {
                        int v1 = (Integer) left.getValue();
                        int v2 = (Integer) right.getValue();
                        
                        if (op.kind == LT)      res = v1 < v2;
                        else if (op.kind == GT) res = v1 > v2;
                        else if (op.kind == LE) res = v1 <= v2;
                        else if (op.kind == GE) res = v1 >= v2;
                        else if (op.kind == EQ) res = v1 == v2;
                        else if (op.kind == NE) res = v1 != v2;
                    }
                    else if (left.type.equals("float")) {
                        float v1 = (Float) left.getValue();
                        float v2 = (Float) right.getValue();
                        
                        if (op.kind == LT)      res = v1 < v2;
                        else if (op.kind == GT) res = v1 > v2;
                        else if (op.kind == LE) res = v1 <= v2;
                        else if (op.kind == GE) res = v1 >= v2;
                        else if (op.kind == EQ) res = v1 == v2;
                        else if (op.kind == NE) res = v1 != v2;
                    }
                    
                    newVal = res ? 1 : 0;
                }
                
                left = new SemanticRecord("int", newVal, null);
            }
        }
    )*
    
    { return left; }
}

SemanticRecord logicalAndExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("andExpression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = relationalExpression(node)
    (
        op = <AND> {recordToken(); node.addChild(new ParserNode("AND")); }
        right = relationalExpression(node)
        {
            if (left.type != null && right.type != null) {
                if (!left.type.equals("int") || !right.type.equals("int")) {
                    throw new SemanticException(op, "Operador lógico '&&' requer expressões inteiras.");
                }

                Object newVal = null;
                if (left.getValue() != null && right.getValue() != null) {
                    int v1 = (Integer) left.getValue();
                    int v2 = (Integer) right.getValue();
                    
                    boolean res = (v1 != 0) && (v2 != 0);
                    newVal = res ? 1 : 0;
                }
                
                left = new SemanticRecord("int", newVal, null);
            }
        }
    )*
    
    { return left; }
}


SemanticRecord logicalOrExpression(ParserNode parent):
{
    ParserNode node = new ParserNode("logical_or_expression");
    parent.addChild(node);
    SemanticRecord left, right;
    Token op = null;
}
{
    left = logicalAndExpression(node)
    (
        op = <OR> {recordToken(); node.addChild(new ParserNode("OR")); }
        right = logicalAndExpression(node)
        {
            if (left.type != null && right.type != null) {
                if (!left.type.equals("int") || !right.type.equals("int")) {
                    throw new SemanticException(op, "Operador lógico '||' requer expressões inteiras.");
                }
                Object newVal = null;
                
                if (left.getValue() != null && right.getValue() != null) {
                    int v1 = (Integer) left.getValue();
                    int v2 = (Integer) right.getValue();
                    
                    boolean res = (v1 != 0) || (v2 != 0);
                    newVal = res ? 1 : 0;
                }
                
                left = new SemanticRecord("int", newVal, null);
            }
        }
    )*
    
    { return left; }
}

Token assignmentOperators(ParserNode parent):
{
    ParserNode node = new ParserNode("assignmentOperators");
    parent.addChild(node);
    Token t = null;
}
{
    (
          t = <ASSIGN>          { recordToken(); node.addChild(new ParserNode("ASSIGN")); }
        | t = <PLUS_ASSIGN>     { recordToken(); node.addChild(new ParserNode("PLUS_ASSIGN")); }
        | t = <MINUS_ASSIGN>    { recordToken(); node.addChild(new ParserNode("MINUS_ASSIGN")); }
        | t = <MULTIPLY_ASSIGN> { recordToken(); node.addChild(new ParserNode("MULTIPLY_ASSIGN")); }
        | t = <DIVIDE_ASSIGN>   { recordToken(); node.addChild(new ParserNode("DIVIDE_ASSIGN")); }
        | t = <MODULO_ASSIGN>   { recordToken(); node.addChild(new ParserNode("MODULO_ASSIGN")); }
        | t = <BIT_XOR_ASSIGN>  { recordToken(); node.addChild(new ParserNode("BIT_XOR_ASSIGN")); }
        | t = <BIT_AND_ASSIGN>  { recordToken(); node.addChild(new ParserNode("BIT_AND_ASSIGN")); }
        | t = <BIT_OR_ASSIGN>   { recordToken(); node.addChild(new ParserNode("BIT_OR_ASSIGN")); }
        | t = <LSHIFT_ASSIGN>   { recordToken(); node.addChild(new ParserNode("LSHIFT_ASSIGN")); }
        | t = <RSHIFT_ASSIGN>   { recordToken(); node.addChild(new ParserNode("RSHIFT_ASSIGN")); }
    )
    { return t; }
}

void assignmentStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("assignmentStatement");
    parent.addChild(node);
    Token t;
    Token op;
    SemanticRecord result;
    Symbol s;
}
{
    t = <IDENTIFIER> 
    { 
        identifierTable.checkVariable(t); 
        node.addChild(new ParserNode("IDENTIFIER")); 
        s = identifierTable.getSymbol(t);
    }
    op = assignmentOperators(node)
    result = expression(node)

    {
        if (result.type != null) {
            if (op.kind == ASSIGN) {
                if (!s.getType().equals(result.type)) {
                    throw new SemanticException(t, "Erro de Atribuição: Variável '" + t.image + 
                        "' é " + s.getType() + " mas tentou receber " + result.type);
                }
                s.setValue(result.getValue());
            }
            else {
                if (!s.isInitialized()) {
                    throw new SemanticException(t, "Erro: Variável '" + t.image + 
                        "' precisa ser inicializada antes de usar operador composto (" + op.image + ").");
                }
                if (!s.getType().equals(result.type)) {
                     throw new SemanticException(op, "Tipos incompatíveis para operação " + op.image);
                }
                
                Object currentVal = s.getValue();
                Object exprVal = result.getValue();
                Object finalVal = null;

                if (currentVal != null && exprVal != null) {
                    if (s.getType().equals("int")) {
                        int v1 = (Integer) currentVal;
                        int v2 = (Integer) exprVal;

                        if (op.kind == PLUS_ASSIGN)          finalVal = v1 + v2;
                        else if (op.kind == MINUS_ASSIGN)    finalVal = v1 - v2;
                        else if (op.kind == MULTIPLY_ASSIGN) finalVal = v1 * v2;
                        else if (op.kind == DIVIDE_ASSIGN) {
                             if(v2==0) throw new SemanticException(op, "Divisão por zero.");
                             finalVal = v1 / v2;
                        }
                        else if (op.kind == MODULO_ASSIGN)   finalVal = v1 % v2;
                        else if (op.kind == BIT_AND_ASSIGN)  finalVal = v1 & v2;
                        else if (op.kind == BIT_OR_ASSIGN)   finalVal = v1 | v2;
                        else if (op.kind == BIT_XOR_ASSIGN)  finalVal = v1 ^ v2;
                        else if (op.kind == LSHIFT_ASSIGN)   finalVal = v1 << v2;
                        else if (op.kind == RSHIFT_ASSIGN)   finalVal = v1 >> v2;
                    }
                    else if (s.getType().equals("float")) {
                        if (op.kind == MODULO_ASSIGN || op.kind == BIT_AND_ASSIGN || 
                            op.kind == BIT_OR_ASSIGN || op.kind == BIT_XOR_ASSIGN || 
                            op.kind == LSHIFT_ASSIGN || op.kind == RSHIFT_ASSIGN) {
                                throw new SemanticException(op, "Operador " + op.image + " inválido para float.");
                        }

                        float v1 = (Float) currentVal;
                        float v2 = (Float) exprVal;

                        if (op.kind == PLUS_ASSIGN)          finalVal = v1 + v2;
                        else if (op.kind == MINUS_ASSIGN)    finalVal = v1 - v2;
                        else if (op.kind == MULTIPLY_ASSIGN) finalVal = v1 * v2;
                        else if (op.kind == DIVIDE_ASSIGN) {
                             if(v2==0.0f) throw new SemanticException(op, "Divisão por zero.");
                             finalVal = v1 / v2;
                        }
                    }
                }
                if (finalVal != null) {
                    s.setValue(finalVal);
                }
            }
        }
    }
    
    endOfStatement(node)
}

void importStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("import_statement");
    parent.addChild(node);
    Token t;
}
{
    <KW_PAPIBAQUIGRAFAR> { recordToken(); node.addChild(new ParserNode("KW_PAPIBAQUIGRAFAR")); }
    t=<STRING_LITERAL> { symbolTable.putIfAbsent(t.image, t); }
    endOfStatement(node)
}


// Expressão
SemanticRecord expression(ParserNode parent):
{
    ParserNode node = new ParserNode("expression");
    parent.addChild(node);
    SemanticRecord result;
}
{
    result = logicalOrExpression(node)

    { return result; }
}

void expressionStatement(ParserNode parent) :
{
    ParserNode node = new ParserNode("expressionStatement");
    parent.addChild(node);
}
{
    expression(node)
    endOfStatement(node)
}

// Declaração
void variableDeclaration(ParserNode parent):
{
    ParserNode node = new ParserNode("variableDeclaration");
    parent.addChild(node);
    Token t;
    String declaredType;
    SemanticRecord initValue = null;
    Symbol s = null;
}
{
    declaredType = typeSpecifier(node)
    t = <IDENTIFIER>

    {
        identifierTable.add(t, declaredType);
        node.addChild(new ParserNode("IDENTIFIER"));
        s = identifierTable.getSymbol(t);
    }
    
    (
        <ASSIGN> { recordToken(); node.addChild(new ParserNode("ASSIGN")); } 
        
        initValue = expression(node)
        {
            if (initValue.type != null) {
                boolean tiposCompativeis = declaredType.equals(initValue.type) ||
                                               (declaredType.equals("char*") && initValue.type.equals("string"));

                if (!tiposCompativeis) {
                    throw new SemanticException(t, "Erro de Tipo: Variável '" + t.image +
                        "' é do tipo " + declaredType + " mas está sendo inicializada com " + initValue.type);
                }
                s.setValue(initValue.getValue());
            }
        }
    )?
    
    endOfStatement(node)
}

// Fim de uma instrução
void endOfStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("endOfStatement");
    parent.addChild(node);
}
{
      <SEMICOLON> {recordToken(); node.addChild(new ParserNode("SEMICOLON")); }
    | { throwSyntacticError("Instrução sem ponto e vírgula!"); }
}


void ambiguousStatement(ParserNode parent):
{
    ParserNode node = new ParserNode("ambiguousStatement");
    parent.addChild(node);
}
{
    LOOKAHEAD(4) functionDeclaration(node)
  | LOOKAHEAD(4) variableDeclaration(node)
  | LOOKAHEAD(4) functionCallStatement(node)
  | LOOKAHEAD(4) assignmentStatement(node)
  | expressionStatement(node)
}

// Instrução
void statement(ParserNode parent):
{
    ParserNode node = new ParserNode("statement");
    parent.addChild(node);
}
{
    conditionalStatement(node)
  | whileStatement(node)
  | forStatement(node)
  | papibagrifarStatement(node)
  | block(node)
  | importStatement(node)
  | functionReturnStatement(node)
  | breakStatement(node)
  | continueStatement(node)
  | ambiguousStatement(node)
}


// Inicio
void start(ParserNode parent): {}
{
    ( statement(parent))* <EOF>
}

